var ChildProcess = require('child_process');
var os = require('os');
var exec = ChildProcess.exec;
var IS_WIN = process.platform === 'win32';
var TableParser = require( 'table-parser' );
/**
 * End of line.
 * Basically, the EOL should be:
 * - windows: \r\n
 * - *nix: \n
 * But i'm trying to get every possibilities covered.
 */
var EOL = /(\r\n)|(\n\r)|\n|\r/;
var SystemEOL = require( 'os' ).EOL;

function wmic(name,callback){
    // windows 下直接通过exec方法来wmic process get没有stdout，因此通过调用CMD的方法来做
	var spawn = ChildProcess.spawn;
	var CMD = spawn('cmd');
	var stdout = [];
	var stderr = null;
	CMD.stdout.on('data', function (data) {
		stdout += data.toString();
	});
	CMD.stderr.on('data', function (data) {
		if( stderr === null ) stderr = data.toString();
		else stderr += data.toString();
	});
	CMD.on('exit', function () {
		var beginRow;
		stdout = stdout.split( EOL );
		// 寻找到数据的第一行（标题行）
		stdout = stdout.filter((item)=>{
			return item!=='\r\n'&&item!==''&&item !== undefined  //rm empty lines
		})
		stdout.forEach(function( out, index ){
			if( out && out.indexOf( 'IDProcess' ) === 0 ){
				beginRow = index;
			}
		});
		// 去掉开头和结尾 （开头为CMD的版权等，结尾为当前路径）
		stdout.splice( stdout.length - 1 , 1 );
		stdout.splice( 0 , beginRow );
		callback( stderr, stdout.join( SystemEOL ) || false );
	});
	// | findstr /v /c:"---"
	let cmd = 'wmic path Win32_PerfFormattedData_PerfProc_Process where "name like \'%'+name+'%\'" get IDProcess,Name,PercentProcessorTime,WorkingSetPrivate \n'// | findstr /i /c:"---"\n'
	
	CMD.stdin.write(cmd);
	CMD.stdin.end();
}
/**
 * Execute child process
 * @type {Function}
 * @param {String[]} args
 * @param {Function} callback
 * @param {Object=null} callback.err
 * @param {Object[]} callback.stdout
 */
var Exec = module.exports = exports = function( query, callback) {
    if( IS_WIN ){
		wmic(query.name,callback);
    } else {
		//console.log('args='+args)
		let except_str = query.except?'|grep -v ' + query.except:''
        exec( 'ps aux |head -1; ps aux|grep '+query.name+'|grep -v grep ' + except_str, function( err, stdout, stderr) {
            if (err || stderr) {
                return callback( err || stderr.toString() );
            }else {
                stdout = stdout.toString();
                callback(null, stdout || false);
            }
        });
    }
};

/**
 * Query Process: Focus on pid & cmd
 * @param query
 * @param {String|String[]} query.pid
 * @param {String} query.command RegExp String
 * @param {String} query.arguments RegExp String
 * @param {Function} callback
 * @param {Object=null} callback.err
 * @param {Object[]} callback.processList
 * @return {Object}
 */

exports.lookup = function(query, callback) {

    /**
     * add 'l' as default ps arguments, since the default ps output in linux like "ubuntu", wont include command arguments
     */
    //var exeArgs = query.psargs || [ 'l' ];
    var filter = {};
    var idList;

    // Lookup by PID
    if ( query.pid ) {

        if( Array.isArray( query.pid ) ){
            idList = query.pid;
        }
        else {
            idList = [ query.pid ];
        }

        // Cast all PIDs as Strings
        idList = idList.map( function( v ){
            return String( v );
        } );

    }


    if( query.command ){
        filter[ 'command' ] = new RegExp( query.command, 'i' );
    }

    if( query.arguments ){
        filter[ 'arguments' ] = new RegExp( query.arguments, 'i' );
    }

    if( query.ppid ){
        filter['ppid'] = new RegExp( query.ppid );
    }

    return Exec( query, function(err, output) {
        if (err) {
            return callback( err );
        }
        else {
            var processList = parseGrid( output );
            var resultList = [];

            processList.forEach(function( p ){

                var flt;
                var type;
                var result = true;
                // 若限定了id列表
                if( idList && idList.indexOf( String( p.pid ) ) < 0 ){
                    return;
                }

                for( type in filter ){
                    flt = filter[ type ];
                    result = flt.test( p[ type ] ) ? result : false;
                }

                if( result ){
                    resultList.push( p );
                }
            });

            callback( null, resultList );
        }
    });
};

/**
 * Kill process
 * @param pid
 * @param next
 */

exports.kill = function( pid, next ){
    var killCommand = IS_WIN ? 'taskkill ' : 'kill ';
    var command = killCommand + ( IS_WIN ? '/F /PID ' + pid : pid );
    ChildProcess.exec( command, function( err, stdout, stderr) {
        if (typeof next !== 'function') return;
        if ((err || stderr)) {
            next( err || stderr.toString() );
        }
        else {
            stdout = stdout.toString();

            // 在windows下，kill完马上查询会出现还能找到刚刚被kill的进程的情况，因此等待200ms，然后再认为kill结束
            if( IS_WIN ){
                setTimeout(function(){
                    next( null, stdout );
                }, 200 );
            }
            else {
                next( null, stdout );
            }
        }
    });
};

/**
 * Parse the stdout into readable object.
 * @param {String} output
 */

function parseGrid( output ) {
    if ( !output ) {
        return output;
    }
    return formatOutput( TableParser.parse( output ) );
}

/**
 * 格式化输出结构，从里面提取出 pid, command, arguments
 * @param data
 * @return {Array}
 */

function formatOutput( data ){
    var formatedData = [];
	//console.log('formatOutput:'+data)
    data.forEach(function( d ){
		//Windows:   IDProcess,Name,PercentProcessorTime,WorkingSetPrivate
		//Mac/Linux: PID,COMMAND,%CPU,%MEM
        var pid = ( d.PID && d.PID[ 0 ] ) || ( d.ProcessId && d.ProcessId[ 0 ] ) || ( d.IDProcess && d.IDProcess[ 0 ] ) || undefined;
        var cmd = d.CMD || d.CommandLine || d.COMMAND || d.Name || undefined;
        var cpu = ( d['%CPU'] && d['%CPU'][ 0 ] ) || ( d.PercentProcessorTime && d.PercentProcessorTime[ 0 ] ) || undefined;
        var mem = ( d['%MEM'] && d['%MEM'][ 0 ] ) || ( d.WorkingSetPrivate && d.WorkingSetPrivate[ 0 ] ) || undefined;
        var ppid = ( d.PPID && d.PPID[ 0 ] ) || undefined;

        if( pid && cmd ){
            var command = cmd[ 0 ];
            var args = '';

            if( cmd.length > 1 ){
                args = cmd.slice( 1 );
            }
			if(mem>100) mem = (100*mem/os.totalmem()).toFixed(2)
            formatedData.push({
                pid: pid,
                command: command,
                arguments: args,
                ppid: ppid,
                cpu:cpu,
                mem:mem,
            });
			
        }
    });

    return formatedData;
}
